# Написать свой cache декоратор c максимальным размером кеша и его очисткой при
# необходимости. Декоратор должен перехватывать аргументы оборачиваемой функции
# Декоратор должен иметь хранилище, где будут сохраняться все перехваченные аргументы и результаты
# выполнения декорируемой функции. Декоратор должен проверять наличие перехваченных аргументов в
# хранилище. Если декорируемая функция уже вызывалась с такими аргументами, она не будет вызываться
# снова, вместо этого декоратор вернет сохраненное значение. Декоратор должен принимать один
# аргумент - максимальный размер хранилища. Если хранилище заполнено, нужно удалить 1 любой элемент,
# чтобы освободить место под новый.
def do_cache(maxsize):
    storage = []

    def _repeat(func):
        def wrapper(*args, **kwargs):
            interceptor = tuple([*args, func(*args, **kwargs)])
            if len(storage) == maxsize:
                storage.pop()
            if not storage.count(interceptor):
                storage.append(interceptor)
            print(storage)
        return wrapper
    return _repeat


@do_cache(maxsize=3)
def get_value(a, b):
    return a ** b


get_value(2, 3)
get_value(3, 3)
get_value(4, 3)
get_value(1, 3)
get_value(4, 2)
